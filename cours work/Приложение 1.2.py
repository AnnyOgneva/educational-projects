# -*- coding: utf-8 -*-
"""Курсовая часть 1.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1BFOpIEqoWZLY138DpbWjolkplFDp0oSp
"""

# Commented out IPython magic to ensure Python compatibility.
from pandas.errors import InvalidIndexError
import pandas as pd
from sklearn.linear_model import LinearRegression
import matplotlib.pyplot as plt
import numpy as np
# %matplotlib inline 
#импортируем модули выше, в моём случае страна Италия

from google.colab import drive
drive.mount('/content/drive')

#data= pd.read_excel("/content/drive/MyDrive/Мучёба/3,5к/курсач/Книга 8.xlsx")
#загружаем данные из таблицы (LN y посчитали в excel) и смотрим 
data= pd.read_excel("/content/drive/MyDrive/Мучёба/3,5к/курсач/Книга 8.xlsx")

data

plt.plot(data['year'], data['y'])

plt.legend(['Y'])

mean_GDP = data['y'].to_numpy().mean()
mean_growth = (data['y'][69]/data['y'][0])**(1/70)
print('среднй размер ВВП', mean_GDP,'средний темп роста' ,mean_growth)
#считаем среднй размер ВВП и средний темп роста

trend = LinearRegression()
trend.fit(data['year'].to_numpy().reshape(-1,1), data['LN y'].to_numpy().reshape(-1,1))
pred = trend.predict(data['year'].to_numpy().reshape(-1,1))
#создаём модель линейной регрессии и обучаем её на данных (год и LN y)

trend.coef_

trend.intercept_

plt.plot(data['year'], data['LN y'])
plt.plot(data['year'], pred)
plt.legend(['ln(y)','тренд'])
#Строим графики данных и тренда

def sum_of_errors(y_real1, y_real2, preds1, preds2):
  errors1 = (y_real1 - preds1)**2
  errors2 = (y_real2 - preds2)**2
  errors = sum(np.concatenate([errors1, errors2]))
  return errors
  #создаём отдельную функцию для подсчёта средней квадратической ошибки (будем использовать в дальнейшем)

errors=[]
coof1=[]
coof2=[]

for i in range(6, 64):
  data_for_reg1 = data[:i]
  data_for_reg2 = data[i+1:]

  y1 = data_for_reg1['LN y'].to_numpy().reshape(-1,1)
  x1=data_for_reg1['year'].to_numpy().reshape(-1,1)
  y2 = data_for_reg2['LN y'].to_numpy().reshape(-1,1)
  x2=data_for_reg2['year'].to_numpy().reshape(-1,1)

  trend1 = LinearRegression().fit(x1,y1)
  trend2 = LinearRegression().fit(x2,y2)

  coof1.append([trend1.coef_[0][0], trend1.intercept_[0]])
  coof2.append([trend2.coef_[0][0], trend2.intercept_[0]])

  pret1=trend1.predict(x1)
  pret2=trend2.predict(x2)

  errors.append(sum_of_errors(y1,y2,pret1,pret2))

#строим линейные регрессии в цикле по данным каждый раз сдвигаясь на строку и сохраням ошибки

coof1[35]

coof2[35]

min(errors)
len(errors)
#Смотрим минимальную ошибку так как лет 70 добавляем 12

errors.index(min(errors))+6
#ищем индекс минимальной ошибки

data['year'][35]
#ищем год с  минимальной ошибкой

data_before=data[:35]
data_after=data[36:]

#делим данные до и после точки перелома

y1 = data_before['LN y'].to_numpy().reshape(-1,1)
x1=data_before['year'].to_numpy().reshape(-1,1)
y2 = data_after['LN y'].to_numpy().reshape(-1,1)
x2=data_after['year'].to_numpy().reshape(-1,1)

trend_before = LinearRegression()
trend_before.fit(x1,y1)
trend_after = LinearRegression()
trend_after.fit(x2,y2)

pret_before=trend_before.predict(x1)
pret_after=trend_after.predict(x2)

#создаём и обучаем 2 модели линейной регрессии (до и после точки перелома)

plt.plot(data['year'], data['LN y'])
plt.plot(x1, pret_before)
plt.plot(x2, pret_after)
plt.legend(['ln(y)','тренд 1','тренд 2'])
#стрим их графики и график данных

sr_temp1= ((data['y'][34]/data['y'][0])**(1/35)-1)*100
sr_temp2= ((data['y'][69]/data['y'][36])**(1/34)-1)*100
print('редние темпы роста до точки перелома',sr_temp1, 'редние темпы роста после точки перелома',sr_temp2)
#ищем средние темпы роста по периодам